/* SEÇÃO 19 - AUTOMATIZANDO AS COISAS - TRIGGERS */
 
/* 79. INTRODUÇÃO AS FANTÁSTICAS TRIGGERS (GATILHO)

ESTRUTURA DE UMA TRIGGER

CREATE TRIGGER NOME
BEFORE/AFTER INSERT/DELETE/UPDATE ON TABELA ## AQUI VAMOS DIZER SE ELE DISPARARA ANTES (BEFORE) OU DEPOIS (AFTER) DE ALGUNS\
 DESSES COMANDOS (INSERT, DELETE, UPDATE)
FOR EACH ROW (PARA CADA LINHA)
BEGIN -> INICIO

		QUALQUER COMANDO SQL ## E ELE EXECUTARA O COMANDO QUE DEFINIRMOS NESSE BLOCO

END -> FIM

OBERVAÇÃO¹: DENTRO DO BLOCO DE COMANDO NÓS TEREMOS QUE USAR O DELIMITADOR PADRÃO QUE É O PONTO E VÍRGULA, LOGO,\
 TEREMOS QUE ALTERAR O DELIMITADOR PARA UTILIZARMOS NO END SEJA $ OU &
OBSERVAÇÃO²: O MYSQL ACOMPANHA A CONFIGURAÇÃO DE CASE SENSITIVE DO SISTEMA OPERACIONAL QUE ELE ESTÁ INSTALADO,\
 ENTÃO SE ELE ESTIVER INSTALADO EM WINDOWS QUE NÃO É CASE SENTITIVE, ELE NÃO SERÁ, MAS SE ELE FOR INSTALDO NO LINUX \
 QUE É, LOGO SERA CASE SENTITIVE. */
 
 
/* 80. AGORA É PRA VALER! TRIGGER NA PRÁTICA!


TEMOS QUE TER EM MENTE QUE PODEMOS INSERIR EM UMA TABELA DUAS TRIGGERS QUE OCORREM NO NO MESMO MOMENTO, MAS POSSO TER\
DIVERSAS OUTRAS TRIGGERS NA MESMA TABELA, MAS QUE OCORREM EM MOMENTOS DIFERENTES. POR EXEMPLO: UMA TRIGGER QUE OCORRE\
ANTES DE UM DELETE E OUTRA QUE OCORRE DEPOIS DE UM DELETE, MAS NUNCA DUAS QUE OCORREM ANTES DO DELETE

OUTRO PONTO, SE EU ESTOU INSERINGO ALGO NA TABELA ESSE VALOR É NEW, MAS SE ESTOU DELETANDO ALGO DA TABELA É OLD E NO UPDATE\
O VALOR QUE ENTRA É NEW E O QUE SAI É OLD

*/

CREATE DATABASE AULA80;

USE AULA40;

/* O INTUITO DAS TABELAS QUE ESTAMOS CRIANDO É QUE TODA VEZ QUE APAGARMOS UM USUÁRIO DA TABELA, SEJA REALIZADO O BKP\
PARA PODEMOS RETORNÁ-LO QUANDO QUISERMOS*/

CREATE TABLE USUARIO(
	IDUSUARIO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	LOGIN VARCHAR(30),
	SENHA VARCHAR(100)
);

CREATE TABLE BKP_USUARIO(
	IDBACKUP INT PRIMARY KEY AUTO_INCREMENT,
	IDUSUARIO INT,
	NOME VARCHAR(30),
	LOGIN VARCHAR(30)
);

/* CRIANDO A TRIGGER */

DELIMITER $


CREATE TRIGGER BACKUP_USER
BEFORE DELETE ON USUARIO
FOR EACH ROW 
BEGIN		
	INSERT INTO BKP_USUARIO VALUES
	(NULL,OLD.IDUSUARIO,OLD.NOME,OLD.LOGIN); 
END
$

DELIMITER ; 

INSERT INTO USUARIO VALUES(NULL,'ANDRADE','ANDRADE2009','HEXACAMPEAO');

SELECT * FROM USUARIO;

DELETE FROM USUARIO WHERE IDUSUARIO = 1;

SELECT * FROM BKP_USUARIO;

/* 81. TRIGGERS PARA BANCOS DE BACKUP 

QUANDO REALIZAMOS UM BKP DE UMA TABELA EM OUTRA TABELA, ISSO É UM BKP LÓGICO
QUANDO REALIZAMOS A COPIA EM UMA FITA, OU DVD, É UM BKP FISICO 

O QUE VEREREMOS AGORA É COMO REALIZAR UM BKP DE UMM BANCO EM OUTRO BANCO*/

CREATE DATABASE LOJA;

USE LOJA;

CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

STATUS

CREATE DATABASE BACKUP;

USE BACKUP;

CREATE TABLE BKP_PRODUTO(
	IDBKP INT PRIMARY KEY AUTO_INCREMENT,
	IDPRODUTO INT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

USE LOJA;

STATUS
-- COMO ESTAMOS NO BANCO LOJA E QUEREMOS INSERIR UM VALOR NA TABELA BKP_PRODUTO, QUE PER\
-- TENCE AO BANCO BACKUP, PRECISAMOS EXPLICITAR ISSO E O FAZEMOS ATRAVÉS DO NOMEDOBANCO.TABELADOBANCO
INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,1000,'TESTE',0.0);

SELECT * FROM BACKUP.BKP_PRODUTO;


-- VAMOS CRIAR UMA TRIGGER PARA QUE SEMPRE QUE INSERIRMOS UM NOVO VALOR NA TABELA PRODUTO, ELE REALIZE
-- UMA INSERÇÃO DE BKP NA TABELA BKP_PRODUTO
DELIMITER $

CREATE TRIGGER BACKUP_PRODUT
BEFORE INSERT ON PRODUTO
FOR EACH ROW
BEGIN	
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,NEW.IDPRODUTO,
	NEW.NOME,NEW.VALOR);
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES(NULL,'LIVRO MODELAGEM',50.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO BI',80.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO ORACLE',70.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO SQL SERVER',100.00);

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

-- OU PODEMOS FAZER O BKP SOMENTE QUANDO FORMOS DELETAR O PRODUTO, ENTÃO ELE ANTES DE REALIZAR\
-- O DELETE, ELE FARÁ UMA CÓPIA

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,OLD.IDPRODUTO,
	OLD.NOME,OLD.VALOR);
END
$

DELIMITER ;

DELETE FROM PRODUTO WHERE IDPRODUTO = 2;

DROP TRIGGER BACKUP_PRODUT;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO
AFTER INSERT ON PRODUTO
FOR EACH ROW
BEGIN	
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,NEW.IDPRODUTO,
	NEW.NOME,NEW.VALOR);
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES(NULL,'LIVRO C#',100.00);


SELECT * FROM PRODUTO;
SELECT * FROM BACKUP.BKP_PRODUTO;

/* 82. AFTER, BEFORE, INSERT, DELETE OU UPDATE? OS EVENTOS DE UMAA TRIGGER

*/

ALTER TABLE BACKUP.BKP_PRODUTO
ADD EVENTO CHAR(1);

DROP TRIGGER BACKUP_PRODUTO_DEL;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW
BEGIN
	
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,OLD.IDPRODUTO,
	OLD.NOME,OLD.VALOR,'D');

END
$

DELIMITER ;
DELETE FROM PRODUTO WHERE IDPRODUTO = 4;

SELECT * FROM BACKUP.BKP_PRODUTO;

/* 83. QUEM MEXEU NO MEU DADO? 

VAMOS VER AGORA O COMANDO UPDATE

VAMOS CONSTRUIR TRIGGER QUE VAI DIZER QUANOD O PRODUTO FOI DELETADO, QUANDO FOI ALTERADO E VAI
GRAVAR O VALOR DA ALTERAÇÃO DO PREÇO DO PROUDUTO */


DELIMITER ;

DROP DATABASE LOJA;

DROP DATABASE BACKUP;

CREATE DATABASE LOJA;

USE LOJA;

CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

INSERT INTO PRODUTO VALUES(NULL,'LIVRO MODELAGEM',50.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO BI',80.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO ORACLE',70.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO SQL SERVER',100.00);

-- QUANDO
SELECT NOW();
-- QUEM
SELECT CURRENT_USER();

CREATE DATABASE BACKUP;

USE BACKUP;

CREATE TABLE BKP_PRODUTO(
	IDBACKUP INT PRIMARY KEY AUTO_INCREMENT,
	IDPRODUTO INT,
	NOME VARCHAR(30),
	VALOR_ORIGINAL FLOAT(10,2),
	VALOR_ALTERADO FLOAT(10,2),
	DATA DATETIME,
	USUARIO VARCHAR(30),
	EVENTO CHAR(1)	
);

USE LOJA;

SELECT * FROM PRODUTO;

DELIMITER $

CREATE TRIGGER AUDIT_PROD
AFTER UPDATE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,OLD.IDPRODUTO,OLD.NOME,
	OLD.VALOR,NEW.VALOR,NOW(),CURRENT_USER(),'U');	
END
$

DELIMITER ;

UPDATE PRODUTO SET VALOR = 110.00
WHERE IDPRODUTO = 4;

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

UPDATE PRODUTO SET VALOR = 115.00
WHERE IDPRODUTO = 4;
